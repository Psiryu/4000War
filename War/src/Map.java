
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor..
 */
/**
 *
 * @author Prem
 */
public class Map extends javax.swing.JFrame {

    //variable for keeping track of the current players' turns;
    public int x, y;
    //variables for if an army is on the selected node, and if it can be split/merged
    public Boolean armyHere = false;
    public Boolean divisableArmy = false;
    public Boolean mergableArmy = false;
    //nodeSelection is used for selecting a node
    public int nodeSelected = 0;

    /**
     * Creates new form Map
     */
    public Map() {
        initComponents();

        //clears off the information panel
        ClearMenuInfo();
        buttonNext.setVisible(false);
        frameFloatingInfo.setVisible(true);

        //resets turn count to 0;
        Game.turnCount = 0;

        GameStart();
        //jFrame1.setVisible(true);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        popupMenu = new javax.swing.JPopupMenu();
        menuItemClose = new javax.swing.JMenuItem();
        jMenu1 = new javax.swing.JMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();
        frameFloatingInfo = new javax.swing.JFrame();
        labelTurnCount = new javax.swing.JLabel();
        labelCurPlayer = new javax.swing.JLabel();
        buttonFinishTurn = new javax.swing.JButton();
        buttonMenu = new javax.swing.JToggleButton();
        buttonExit = new javax.swing.JButton();
        labelOpponent = new javax.swing.JLabel();
        labelScenario = new javax.swing.JLabel();
        labelPoliticalPower = new javax.swing.JLabel();
        labelSeason = new javax.swing.JLabel();
        list1 = new java.awt.List();
        labelBackdrop = new javax.swing.JLabel();
        butonX = new javax.swing.JButton();
        menuInfo = new javax.swing.JPanel();
        labelInfo1 = new javax.swing.JLabel();
        labelInfo2 = new javax.swing.JLabel();
        labelInfo3 = new javax.swing.JLabel();
        labelInfo4 = new javax.swing.JLabel();
        labelInfo5 = new javax.swing.JLabel();
        labelInfo6 = new javax.swing.JLabel();
        panelMap = new javax.swing.JPanel();
        nodePlaceholder1 = new javax.swing.JButton();
        nodePlaceholder2 = new javax.swing.JButton();
        nodePlaceholder3 = new javax.swing.JButton();
        nodePlaceholder4 = new javax.swing.JButton();
        nodePlaceholder5 = new javax.swing.JButton();
        nodePlaceholder6 = new javax.swing.JButton();
        nodePlaceholder7 = new javax.swing.JButton();
        nodePlaceholder8 = new javax.swing.JButton();
        nodePlaceholder9 = new javax.swing.JButton();
        nodePlaceholder10 = new javax.swing.JButton();
        nodePlaceholder11 = new javax.swing.JButton();
        nodePlaceholder12 = new javax.swing.JButton();
        nodePlaceholder13 = new javax.swing.JButton();
        nodePlaceholder14 = new javax.swing.JButton();
        buttonMapImage = new javax.swing.JButton();
        buttonNext = new javax.swing.JButton();
        buttonBackdrop = new javax.swing.JButton();

        popupMenu.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        popupMenu.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                popupMenuFocusLost(evt);
            }
        });

        menuItemClose.setText("Close Menu");
        menuItemClose.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuItemCloseActionPerformed(evt);
            }
        });
        popupMenu.add(menuItemClose);

        jMenu1.setText("jMenu1");

        jMenuItem1.setText("jMenuItem1");
        jMenu1.add(jMenuItem1);

        jMenuItem2.setText("jMenuItem2");
        jMenu1.add(jMenuItem2);

        popupMenu.add(jMenu1);

        frameFloatingInfo.setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        frameFloatingInfo.setBounds(new java.awt.Rectangle(860, 390, 0, 0));
        frameFloatingInfo.setMaximumSize(new java.awt.Dimension(420, 275));
        frameFloatingInfo.setMinimumSize(new java.awt.Dimension(420, 275));
        frameFloatingInfo.setName(""); // NOI18N
        frameFloatingInfo.setUndecorated(true);
        frameFloatingInfo.setPreferredSize(new java.awt.Dimension(420, 275));
        frameFloatingInfo.setResizable(false);
        frameFloatingInfo.getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        labelTurnCount.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        labelTurnCount.setText("Turn: 1");
        frameFloatingInfo.getContentPane().add(labelTurnCount, new org.netbeans.lib.awtextra.AbsoluteConstraints(220, 70, -1, -1));

        labelCurPlayer.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        labelCurPlayer.setText("text");
        frameFloatingInfo.getContentPane().add(labelCurPlayer, new org.netbeans.lib.awtextra.AbsoluteConstraints(290, 70, -1, -1));

        buttonFinishTurn.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        buttonFinishTurn.setText("Finish Turn");
        buttonFinishTurn.setContentAreaFilled(false);
        buttonFinishTurn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonFinishTurnActionPerformed(evt);
            }
        });
        frameFloatingInfo.getContentPane().add(buttonFinishTurn, new org.netbeans.lib.awtextra.AbsoluteConstraints(277, 10, -1, 40));

        buttonMenu.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        buttonMenu.setText("Main Menu");
        buttonMenu.setToolTipText(null);
        buttonMenu.setContentAreaFilled(false);
        buttonMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonMenuActionPerformed(evt);
            }
        });
        frameFloatingInfo.getContentPane().add(buttonMenu, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 10, 100, 40));

        buttonExit.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        buttonExit.setText("End Game");
        buttonExit.setContentAreaFilled(false);
        buttonExit.setMaximumSize(new java.awt.Dimension(83, 23));
        buttonExit.setMinimumSize(new java.awt.Dimension(83, 23));
        buttonExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonExitActionPerformed(evt);
            }
        });
        frameFloatingInfo.getContentPane().add(buttonExit, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 10, 100, 40));

        labelOpponent.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        labelOpponent.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        labelOpponent.setText("text");
        labelOpponent.setName("labelOpponent"); // NOI18N
        frameFloatingInfo.getContentPane().add(labelOpponent, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 70, -1, -1));

        labelScenario.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        labelScenario.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        labelScenario.setText("text");
        frameFloatingInfo.getContentPane().add(labelScenario, new org.netbeans.lib.awtextra.AbsoluteConstraints(130, 70, -1, -1));

        labelPoliticalPower.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        labelPoliticalPower.setText("text");
        frameFloatingInfo.getContentPane().add(labelPoliticalPower, new org.netbeans.lib.awtextra.AbsoluteConstraints(220, 90, -1, -1));

        labelSeason.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        labelSeason.setText("text");
        frameFloatingInfo.getContentPane().add(labelSeason, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 90, -1, -1));
        frameFloatingInfo.getContentPane().add(list1, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 110, 400, 140));

        labelBackdrop.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/MapScreen-Side-backdrop.png"))); // NOI18N
        labelBackdrop.setToolTipText(null);
        frameFloatingInfo.getContentPane().add(labelBackdrop, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, 420, -1));

        frameFloatingInfo.getAccessibleContext().setAccessibleParent(frameFloatingInfo);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(204, 255, 255));
        setMaximumSize(new java.awt.Dimension(860, 560));
        setMinimumSize(new java.awt.Dimension(860, 560));
        setUndecorated(true);
        setResizable(false);
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        butonX.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/X.png"))); // NOI18N
        butonX.setBorderPainted(false);
        butonX.setContentAreaFilled(false);
        butonX.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                butonXActionPerformed(evt);
            }
        });
        getContentPane().add(butonX, new org.netbeans.lib.awtextra.AbsoluteConstraints(840, 0, 20, -1));

        menuInfo.setMaximumSize(new java.awt.Dimension(700, 70));
        menuInfo.setMinimumSize(new java.awt.Dimension(700, 70));
        menuInfo.setOpaque(false);
        menuInfo.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        labelInfo1.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        labelInfo1.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        labelInfo1.setText("city name");
        menuInfo.add(labelInfo1, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 10, -1, -1));

        labelInfo2.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        labelInfo2.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        labelInfo2.setText("node type");
        menuInfo.add(labelInfo2, new org.netbeans.lib.awtextra.AbsoluteConstraints(180, 10, -1, -1));

        labelInfo3.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        labelInfo3.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        labelInfo3.setText("supplies");
        menuInfo.add(labelInfo3, new org.netbeans.lib.awtextra.AbsoluteConstraints(400, 10, -1, -1));

        labelInfo4.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        labelInfo4.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        labelInfo4.setText("weather");
        menuInfo.add(labelInfo4, new org.netbeans.lib.awtextra.AbsoluteConstraints(530, 10, -1, -1));

        labelInfo5.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        labelInfo5.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        labelInfo5.setText("player's armies");
        menuInfo.add(labelInfo5, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 40, -1, -1));

        labelInfo6.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        labelInfo6.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        labelInfo6.setText("enemy's armies");
        menuInfo.add(labelInfo6, new org.netbeans.lib.awtextra.AbsoluteConstraints(400, 40, -1, -1));

        getContentPane().add(menuInfo, new org.netbeans.lib.awtextra.AbsoluteConstraints(70, 480, -1, -1));

        panelMap.setMaximumSize(new java.awt.Dimension(820, 470));
        panelMap.setMinimumSize(new java.awt.Dimension(820, 470));
        panelMap.setOpaque(false);
        panelMap.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        nodePlaceholder1.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-town.png"))); // NOI18N
        nodePlaceholder1.setOpaque(false);
        nodePlaceholder1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder1ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder1, new org.netbeans.lib.awtextra.AbsoluteConstraints(80, 410, 30, 30));

        nodePlaceholder2.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-town.png"))); // NOI18N
        nodePlaceholder2.setOpaque(false);
        nodePlaceholder2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder2ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder2, new org.netbeans.lib.awtextra.AbsoluteConstraints(150, 70, 30, 30));

        nodePlaceholder3.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder3.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-town.png"))); // NOI18N
        nodePlaceholder3.setOpaque(false);
        nodePlaceholder3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder3ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder3, new org.netbeans.lib.awtextra.AbsoluteConstraints(220, 90, 30, 30));

        nodePlaceholder4.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder4.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-town.png"))); // NOI18N
        nodePlaceholder4.setOpaque(false);
        nodePlaceholder4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder4ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder4, new org.netbeans.lib.awtextra.AbsoluteConstraints(190, 140, 30, 30));

        nodePlaceholder5.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder5.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-town.png"))); // NOI18N
        nodePlaceholder5.setOpaque(false);
        nodePlaceholder5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder5ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder5, new org.netbeans.lib.awtextra.AbsoluteConstraints(200, 170, 30, 30));

        nodePlaceholder6.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder6.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-port.png"))); // NOI18N
        nodePlaceholder6.setOpaque(false);
        nodePlaceholder6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder6ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder6, new org.netbeans.lib.awtextra.AbsoluteConstraints(280, 180, 30, 30));

        nodePlaceholder7.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder7.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-town.png"))); // NOI18N
        nodePlaceholder7.setOpaque(false);
        nodePlaceholder7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder7ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder7, new org.netbeans.lib.awtextra.AbsoluteConstraints(220, 200, 30, 30));

        nodePlaceholder8.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder8.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-town.png"))); // NOI18N
        nodePlaceholder8.setOpaque(false);
        nodePlaceholder8.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder8ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder8, new org.netbeans.lib.awtextra.AbsoluteConstraints(260, 220, 30, 30));

        nodePlaceholder9.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder9.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-town.png"))); // NOI18N
        nodePlaceholder9.setOpaque(false);
        nodePlaceholder9.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder9ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder9, new org.netbeans.lib.awtextra.AbsoluteConstraints(310, 260, 30, 30));

        nodePlaceholder10.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder10.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-town.png"))); // NOI18N
        nodePlaceholder10.setOpaque(false);
        nodePlaceholder10.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder10ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder10, new org.netbeans.lib.awtextra.AbsoluteConstraints(340, 280, 30, 30));

        nodePlaceholder11.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder11.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-port.png"))); // NOI18N
        nodePlaceholder11.setOpaque(false);
        nodePlaceholder11.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder11ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder11, new org.netbeans.lib.awtextra.AbsoluteConstraints(465, 291, 30, 30));

        nodePlaceholder12.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder12.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-port.png"))); // NOI18N
        nodePlaceholder12.setOpaque(false);
        nodePlaceholder12.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder12ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder12, new org.netbeans.lib.awtextra.AbsoluteConstraints(530, 270, 30, 30));

        nodePlaceholder13.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder13.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-town.png"))); // NOI18N
        nodePlaceholder13.setOpaque(false);
        nodePlaceholder13.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder13ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder13, new org.netbeans.lib.awtextra.AbsoluteConstraints(720, 270, 30, 30));

        nodePlaceholder14.setBackground(new java.awt.Color(0, 0, 0));
        nodePlaceholder14.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/map-node-port.png"))); // NOI18N
        nodePlaceholder14.setOpaque(false);
        nodePlaceholder14.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodePlaceholder14ActionPerformed(evt);
            }
        });
        panelMap.add(nodePlaceholder14, new org.netbeans.lib.awtextra.AbsoluteConstraints(230, 230, 30, 30));

        buttonMapImage.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Map1_Sulla.png"))); // NOI18N
        buttonMapImage.setText("jButton1");
        buttonMapImage.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        buttonMapImage.setContentAreaFilled(false);
        buttonMapImage.setIconTextGap(0);
        buttonMapImage.setMaximumSize(new java.awt.Dimension(800, 450));
        buttonMapImage.setMinimumSize(new java.awt.Dimension(800, 450));
        buttonMapImage.setPreferredSize(new java.awt.Dimension(800, 450));
        buttonMapImage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonMapImageActionPerformed(evt);
            }
        });
        panelMap.add(buttonMapImage, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 10, -1, -1));

        getContentPane().add(panelMap, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 10, -1, -1));

        buttonNext.setBackground(new java.awt.Color(255, 255, 255));
        buttonNext.setFont(new java.awt.Font("Times New Roman", 0, 36)); // NOI18N
        buttonNext.setContentAreaFilled(false);
        buttonNext.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonNextActionPerformed(evt);
            }
        });
        getContentPane().add(buttonNext, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 20, 800, 450));

        buttonBackdrop.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/mapscreen-main.png"))); // NOI18N
        buttonBackdrop.setBorderPainted(false);
        buttonBackdrop.setContentAreaFilled(false);
        buttonBackdrop.setMaximumSize(new java.awt.Dimension(860, 560));
        buttonBackdrop.setMinimumSize(new java.awt.Dimension(860, 560));
        buttonBackdrop.setPreferredSize(new java.awt.Dimension(860, 560));
        buttonBackdrop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonBackdropActionPerformed(evt);
            }
        });
        getContentPane().add(buttonBackdrop, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, 860, 560));

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public final void GameStart() {
        //this method applies values that are required at the very start of the
        //game for player 1. (essentially "finish turn" button aftereffects
        //that need to happen for th every first turn).

        //sets a label that informs you whom you are versing.
        if ((Global.opponent) == true) {
            labelOpponent.setText("Against Player");
        } else {
            labelOpponent.setText("Against AI");
        }

        //sets labels for scenario selected, and that it is player 1's turn
        labelScenario.setText("Scenario: " + Global.intScenario);
        if(Global.curPlayer == 0)
            labelCurPlayer.setText("Red team's turn");
        else
            labelCurPlayer.setText("Blue team's turn");
        
        //sets label that displays season
        if(Global.season == 0)
            labelSeason.setText("Season: Winter");
        else if(Global.season == 1)
            labelSeason.setText("Season: Spring");
        else if(Global.season == 2)
            labelSeason.setText("Season: Summer");
        else if(Global.season == 3)
            labelSeason.setText("Season: Autumn");
        
        //sets label that displays current political power level
        if(Global.curPlayer == 0)
            labelPoliticalPower.setText("Political power: " + Scenario.redPlayer.politicalPower);
        else
            labelPoliticalPower.setText("Political power: " + Scenario.bluePlayer.politicalPower);
        
        try {
            SetDefaultColours();
        } catch (IOException ex) {
            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            SetEnemyColours();
        } catch (IOException ex) {
            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
        }
        SetColours();
    }

//Action will control all node-based actions. Dimmed public because no need
//for hidden values, and allows information to be passed more easily
    public void Action() {
        //DISPLAY SUPPLY LEVEL TOO ----------------------------------------------------------------------
        ClearMenuInfo();
        try {
            SetDefaultColours();
        } catch (IOException ex) {
            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            //sets colours of nodes with current player's armies and fog of war info
            SetEnemyColours();
        } catch (IOException ex) {
            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
        }
        SetColours();
        try {
            SetCurrentColour();
        } catch (IOException ex) {
            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
        }

        //sets the info labels for: type of node, the current season,
        //and the current political power lvele, respectively
        labelInfo1.setText(Scenario.listOfNodes[nodeSelected].name);
        
        String nodeType;
        if(Scenario.listOfNodes[nodeSelected].isPort == true)
            nodeType = "Port town";
        else if (Scenario.listOfNodes[nodeSelected].isCity == true)
            nodeType = "City";
        else
            nodeType = "Checkpoint";
        labelInfo2.setText("Location type: " + nodeType);
        
        //displays the supply level of selected node
        labelInfo3.setText("Supply level: " + Scenario.listOfNodes[nodeSelected].suppliesAvailable);
        
        //displays current weather
        String weather = "";
        if(Scenario.game.getWeather() == 0)
            weather = "clear";
        else if(Scenario.game.getWeather() == 1)
            weather = "light rain";
        else if(Scenario.game.getWeather() == 2)
            weather = "heavy rain";
        else if(Scenario.game.getWeather() == 3)
            weather = "drought";
        else if(Scenario.game.getWeather() == 4)
            weather = "flooding";
        else if(Scenario.game.getWeather() == 5)
            weather = "tornado warnings";
        labelInfo4.setText("Weather: " + weather);
        
        EnemiesHere();
        
        mergableArmy = false;
        divisableArmy = false;
        armyHere = false;

        //establishes an army array of all player controlled armies
        int[][] armies = null;
        //calls to fill the array
        armies = ObtainArmies(armies);

        //displays if any of your armies are at the selected node
        ArmiesHere(armies);

        //creates the popup menu to be displayed, containing all actions
        //the user can do at the selected node
        OpenPopup(armies);

    }

    public int[][] ObtainArmies(int[][] listArmy) {
        //creates list to use to keep track of armies.
        //first portion of rectangular array represents the differnt armies
        //within the list. Second portion is [id, size, location, fleet bool].  

        int i = 0;

        //first sets player 1's armies (red team), then does the same
        //for player 2 (blue team). Commented first half only, both sets
        //are exactly identical, just "redPlayer" changed to "bluePlayer"
        if (Global.curPlayer == 0) {
            //sets the array to be the size of player's total army count
            listArmy = new int[Scenario.redPlayer.combatUnits.size()][4];
            //loops for each army in the array
            for (CombatUnit army : Scenario.redPlayer.combatUnits) {
                //sets each army's id
                listArmy[i][0] = army.cUnitID;
                //sets each army's size
                listArmy[i][1] = army.size;
                //sets each army's location
                listArmy[i][2] = army.GetLocation().id;
                //sets an int value for the isFleet bool (1 for if true)
                if (army.isFleet == true) {
                    listArmy[i][3] = 1;
                } else {
                    listArmy[i][3] = 0;
                }
                i++;
            }
        } else if (Global.curPlayer == 1) {
            listArmy = new int[Scenario.bluePlayer.combatUnits.size()][4];
            for (CombatUnit army : Scenario.bluePlayer.combatUnits) {
                //sets each army's id
                listArmy[i][0] = army.cUnitID;
                //sets each army's size
                listArmy[i][1] = army.size;
                //sets each army's location
                listArmy[i][2] = army.GetLocation().id;
                //sets an int value for the isFleet bool (1 for if true)
                if (army.isFleet == true) {
                    listArmy[i][3] = 1;
                } else {
                    listArmy[i][3] = 0;
                }
                i++;
            }
        }

        return listArmy;
    }

    public void ArmiesHere(int[][] armies) {
        //creates a string for user display
        String sizes = "";
        //a counter for if armies can merge (mergable[0] counts small armies,
        //while mergable[1] counts mediums.
        int[] mergable = new int[2];
        mergable[0] = 0;
        mergable[1] = 0;

        //indexer i
        int i = 0;
        for (int[] armie : armies) {
            //checks if current army in array at index is located at this node
            if (nodeSelected == armies[i][2]) {
                //adds army size to user output string and sets "armyHere"
                //to true, for later use. Multiple looped true sets are fine.
                sizes += (ConvertSize(armies[i][1], armies[i][3]) + " ");
                armyHere = true;
                //checks if at least one medium army or higher exists on the
                //selected node, for later use
                if (armies[i][1] > 5) {
                    divisableArmy = true;
                }
                //checks if at least two smalls (that aren't fleets) exist here
                if (armies[i][1] < 6 && armies[i][3] == 0) {
                    mergable[0]++;
                }
                //checks if two or more mediums exist here
                if (armies[i][1] > 5 && armies[i][1] < 11) {
                    mergable[1]++;
                }
                //sets public boolean mergableArmy to true if either values in
                //the array are greater than 1
                if (mergable[0] > 1 || mergable[1] > 1) {
                    mergableArmy = true;
                }
            }
            i++;
        }

        //check for if no armies here, for user output
        if (sizes.equals("")) {
            sizes = "none";
        }

        labelInfo5.setText("Your armies here: " + sizes);
    }

    private void OpenPopup(final int[][] armies) {
        //first clears the popup menu (in case another node was clicked
        //while the menu was still active. Then displays and repopulates it.
        ClearPopupMenu();

        //checks if there are armies on the selected node with armyHere
        if (armyHere.equals(true)) {
            //creates the menu item for movement, as only one army being
            //present is the only requirement for it
            final JMenuItem menuItemMove = new JMenuItem("Movement");
            //adds the action for when this item is clicked
            menuItemMove.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent event) {
                    //sends the army list to InitializeMovement when clicked
                    InitializeMovement(armies);
                }
            });

            //adds this item to the popup menu
            popupMenu.add(menuItemMove);
        }
        //checks if divisableArmy (bool for if an army of medium or higher
        //exists on selected node) is true
        if (divisableArmy.equals(true)) {
            //creates the menu item for dividing
            final JMenuItem menuItemDivide = new JMenuItem("Divide");
            //adds the action for when this item is clicked
            menuItemDivide.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent event) {
                    //sends the army list to DividingArmies when clicked
                    DividingArmies(armies);
                }
            });
            popupMenu.add(menuItemDivide);
        }
        //checks if mergableArmy (bool for if two or more mediums or smalls
        //exists on selected node) is true
        if (mergableArmy.equals(true)) {
            //creates the menu item for merging
            final JMenuItem menuItemMerge = new JMenuItem("Merge");
            //adds the action for when this item is clicked
            menuItemMerge.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent event) {
                    //sends the army list to DividingArmies when clicked
                    BeginMergingArmies(armies);
                }
            });
            popupMenu.add(menuItemMerge);
        }

        //ensures gui is up to date and then displays it at the selected node
        popupMenu.setLocation(x, y);
        popupMenu.updateUI();
        popupMenu.setVisible(true);

    }

    private void InitializeMovement(final int[][] armies) {
        //clears menu and readds new items (armies at the node)
        ClearPopupMenu();

        //first, it re checks which armies are at this node
        //then it adds a new menu item for each individual army.
        //it loops for every item in the array.
        int i = 0;
        for (int[] armie : armies) {
            if (nodeSelected == armies[i][2]) {
                //obtains army size, because the method call being
                //within the next line after it caused issues
                final String armySize = ConvertFullSize(armies[i][1], armies[i][3]);

                //creates a new array item to send out, since nested method
                //can't use the indexing for the array.
                final int[][] armyToMove = new int[1][4];
                armyToMove[0] = armies[i];
                armyToMove[0][0] = armies[i][0];
                armyToMove[0][1] = armies[i][1];
                armyToMove[0][2] = armies[i][2];
                armyToMove[0][3] = armies[i][3];

                //creates the item for this army unit on this location.
                //The action is to send current armyToMove to MoveTo method.
                JMenuItem menuItemMove = new JMenuItem(armySize);
                menuItemMove.addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent event) {
                        MoveTo(armyToMove);
                    }
                });
                //finally, adds this item to the popup menu.
                popupMenu.add(menuItemMove);
            }
            //increments so the loop can procede with proper indexing.
            i++;
        }
        popupMenu.setLocation(x, y);
        popupMenu.updateUI();
        popupMenu.setVisible(true);

    }

    private void MoveTo(final int[][] army) {
        ClearPopupMenu();
        Boolean returnSet = false;

        //loops for every road in the list of roads in Scenario
        for (Road roads : Scenario.listOfRoads) {
            //checks if current locaion in array at index is the selected city
            //first it checks if locationA on the road is the current node,
            //then it will do the same commands for if it is locationB
            if (roads.locationA.id == army[0][2]) {
                if (roads.capacity >= army[0][1]) {
                    //adds locationB name to a final string
                    final String movingTo = roads.locationB.name;
                    //creates the menu item for this road
                    JMenuItem menuItemMove = new JMenuItem(movingTo);
                    final Road roads2 = roads;
                    final String listText = (ConvertFullSize(army[0][1], army[0][3])
                            + "army unit will move from " + roads.locationA.name + " to " +
                            roads.locationB.name);
                    menuItemMove.addActionListener(new ActionListener() {
                        @Override
                        public void actionPerformed(ActionEvent event) {
                            MapEvent.addMovement(army[0][0], roads2, roads2.locationB.id);
                            list1.add(listText);
                            
                            //try catch for setting default node colours
                            try {
                                SetDefaultColours();
                            } catch (IOException ex) {
                                Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            try {
                                //sets colours of nodes with current player's armies
                                SetEnemyColours();
                            } catch (IOException ex) {
                                Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            SetColours();

                            ClearMenuInfo();
                            ClearPopupMenu();
                        }
                    });
                    //finally, adds this item to the popup menu.
                    popupMenu.add(menuItemMove);
                //next if statement checks for fleet-only pathways
                } else if(roads.capacity == 0 && army[0][3] == 1) {
                    //ensures the season is not winter
                    if(Global.season != 0) {
                        
                        //creates the movement for a fleet to travel this road alone
                        final String movingTo = roads.locationB.name;
                        //creates the menu item for this road
                        JMenuItem menuItemMove = new JMenuItem(movingTo);
                        final Road roads2 = roads;
                        final String listText = (ConvertFullSize(army[0][1], army[0][3])
                                + "army unit will move from " + roads.locationA.name + " to " +
                                roads.locationB.name);
                        menuItemMove.addActionListener(new ActionListener() {
                            @Override
                            public void actionPerformed(ActionEvent event) {
                                MapEvent.addMovement(army[0][0], roads2, roads2.locationB.id);
                                list1.add(listText);

                                //try catch for setting default node colours
                                try {
                                    SetDefaultColours();
                                } catch (IOException ex) {
                                    Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                                }
                                try {
                                    //sets colours of nodes with current player's armies
                                    SetEnemyColours();
                                } catch (IOException ex) {
                                    Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                                }
                                SetColours();

                                ClearMenuInfo();
                                ClearPopupMenu();
                            }
                        });
                        //finally, adds this item to the popup menu.
                        popupMenu.add(menuItemMove);
                        
                        
                        //creates an array of all armies to check if the fleet
                        //can ferry a small army
                        int[][] allArmies = null;
                        allArmies = ObtainArmies(allArmies);
                        for(final int[] selectedArmy : allArmies) {
                            //if army is at node, is small, and is not fleet
                            if (selectedArmy[2] == nodeSelected && selectedArmy[1] == 5
                                    && selectedArmy[3] == 0) {
                                //adds locationB name to a final string
                                String movingToFerry = roads.locationB.name;
                                //creates the menu item for this road
                                JMenuItem menuItemMove2 = new JMenuItem("Ferry small army to " + movingToFerry);
                                final Road roads3 = roads;
                                final String listText2 = (ConvertFullSize(army[0][1], army[0][3])
                                        + "army unit will ferry a small army from " + roads.locationA.name + " to " +
                                        roads.locationB.name);
                                menuItemMove.addActionListener(new ActionListener() {
                                    @Override
                                    public void actionPerformed(ActionEvent event) {
                                        MapEvent.addMovementFerry(army[0][0], selectedArmy[0], roads3, roads3.locationB.id);
                                        list1.add(listText2);

                                        //try catch for setting default node colours
                                        try {
                                            SetDefaultColours();
                                        } catch (IOException ex) {
                                            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                                        }
                                        try {
                                            //sets colours of nodes with current player's armies
                                            SetEnemyColours();
                                        } catch (IOException ex) {
                                            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                                        }
                                        SetColours();

                                        ClearMenuInfo();
                                        ClearPopupMenu();
                                    }
                                });
                                //finally, adds this item to the popup menu.
                                popupMenu.add(menuItemMove2);
                                
                            }
                        }
                        
                    }
                }
            } else if (roads.locationB.id == army[0][2]) {
                if (roads.capacity >= army[0][1]) {                
                    //adds locationB name to a final string
                    final String movingTo = roads.locationA.name;
                    //creates the menu item for this road
                    JMenuItem menuItemMove = new JMenuItem(movingTo);
                    final Road roads2 = roads;
                    final String listText = (ConvertFullSize(army[0][1], army[0][3]) +
                            "army unit will move from " + roads.locationB.name + " to " +
                            roads.locationA.name);
                    menuItemMove.addActionListener(new ActionListener() {
                        @Override
                        public void actionPerformed(ActionEvent event) {
                            MapEvent.addMovement(army[0][0], roads2, roads2.locationA.id);
                            list1.add(listText);
                            
                            //try catch for setting default node colours
                            try {
                                SetDefaultColours();
                            } catch (IOException ex) {
                                Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            try {
                                //sets colours of nodes with current player's armies
                                SetEnemyColours();
                            } catch (IOException ex) {
                                Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            SetColours();

                            ClearMenuInfo();
                            ClearPopupMenu();
                        }
                    });
                    //finally, adds this item to the popup menu.
                    popupMenu.add(menuItemMove);
                } else if(roads.capacity == 0 && army[0][3] == 1) {
                    //ensures the season is not winter
                    if(Global.season != 0) {
                        //creates the movement for a fleet to travel this road alone
                        final String movingTo = roads.locationA.name;
                        //creates the menu item for this road
                        JMenuItem menuItemMove = new JMenuItem(movingTo);
                        final Road roads2 = roads;
                        final String listText = (ConvertFullSize(army[0][1], army[0][3])
                                + "army unit will move from " + roads.locationB.name + " to " +
                                roads.locationA.name);
                        menuItemMove.addActionListener(new ActionListener() {
                            @Override
                            public void actionPerformed(ActionEvent event) {
                                MapEvent.addMovement(army[0][0], roads2, roads2.locationA.id);
                                list1.add(listText);

                                //try catch for setting default node colours
                                try {
                                    SetDefaultColours();
                                } catch (IOException ex) {
                                    Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                                }
                                try {
                                    //sets colours of nodes with current player's armies
                                    SetEnemyColours();
                                } catch (IOException ex) {
                                    Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                                }
                                SetColours();

                                ClearMenuInfo();
                                ClearPopupMenu();
                            }
                        });
                        //finally, adds this item to the popup menu.
                        popupMenu.add(menuItemMove);
                        
                        
                        //creates an array of all armies to check if the fleet
                        //can ferry a small army
                        int[][] allArmies = null;
                        allArmies = ObtainArmies(allArmies);
                        for(final int[] selectedArmy : allArmies) {
                            //if army is at node, is small, and is not fleet
                            if (selectedArmy[2] == nodeSelected && selectedArmy[1] == 5
                                    && selectedArmy[3] == 0) {
                                //adds locationB name to a final string
                                final String movingTo2 = roads.locationA.name;
                                //creates the menu item for this road
                                JMenuItem menuItemMove2 = new JMenuItem("Ferry small army to " + movingTo2);
                                final Road roads22 = roads;
                                final String listText2 = (ConvertFullSize(army[0][1], army[0][3])
                                        + "army unit will ferry a small army from " + roads.locationB.name + " to " +
                                        roads.locationA.name);
                                menuItemMove.addActionListener(new ActionListener() {
                                    @Override
                                    public void actionPerformed(ActionEvent event) {
                                        MapEvent.addMovementFerry(army[0][0], selectedArmy[0], roads22, roads22.locationA.id);
                                        list1.add(listText2);

                                        //try catch for setting default node colours
                                        try {
                                            SetDefaultColours();
                                        } catch (IOException ex) {
                                            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                                        }
                                        try {
                                            //sets colours of nodes with current player's armies
                                            SetEnemyColours();
                                        } catch (IOException ex) {
                                            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                                        }
                                        SetColours();

                                        ClearMenuInfo();
                                        ClearPopupMenu();
                                    }
                                });
                                //finally, adds this item to the popup menu.
                                popupMenu.add(menuItemMove2);
                                
                            }
                        }
                        
                        
                    }
                }
            } 
            if(roads.locationA.id == army[0][2] && returnSet == false) {
                returnSet = true;
                //for keeping an army at the current node (to cancel a move)
                    final String movingTo = roads.locationA.name;
                    //creates the menu item for this road
                    JMenuItem menuItemMove = new JMenuItem("Stay at " + movingTo);
                    final Road roads2 = roads;
                    final String listText = (ConvertFullSize(army[0][1], army[0][3]) +
                            "army unit will remain at " + roads.locationA.name);
                    menuItemMove.addActionListener(new ActionListener() {
                        @Override
                        public void actionPerformed(ActionEvent event) {
                            MapEvent.addMovement(army[0][0], roads2, roads2.locationA.id);
                            list1.add(listText);
                            
                            //try catch for setting default node colours
                            try {
                                SetDefaultColours();
                            } catch (IOException ex) {
                                Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            try {
                                //sets colours of nodes with current player's armies
                                SetEnemyColours();
                            } catch (IOException ex) {
                                Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            SetColours();

                            ClearMenuInfo();
                            ClearPopupMenu();
                        }
                    });
                    //finally, adds this item to the popup menu.
                    popupMenu.add(menuItemMove);
            }  else if(roads.locationB.id == army[0][2] && returnSet == false) {
                returnSet = true;
                //for keeping an army at the current node (to cancel a move)
                    final String movingTo = "Stay at " + roads.locationB.name;
                    //creates the menu item for this road
                    JMenuItem menuItemMove = new JMenuItem(movingTo);
                    final Road roads2 = roads;
                    final String listText = (ConvertFullSize(army[0][1], army[0][3]) +
                            "army unit will remain at " + roads.locationB.name);
                    menuItemMove.addActionListener(new ActionListener() {
                        @Override
                        public void actionPerformed(ActionEvent event) {
                            MapEvent.addMovement(army[0][0], roads2, roads2.locationB.id);
                            list1.add(listText);
                            
                            //try catch for setting default node colours
                            try {
                                SetDefaultColours();
                            } catch (IOException ex) {
                                Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            try {
                                //sets colours of nodes with current player's armies
                                SetEnemyColours();
                            } catch (IOException ex) {
                                Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            SetColours();

                            ClearMenuInfo();
                            ClearPopupMenu();
                        }
                    });
                    //finally, adds this item to the popup menu.
                    popupMenu.add(menuItemMove);
            }
        }
        //adds the menu item for canceling movement
        

        //re-sets the popupmenu as updated and visible
        popupMenu.setLocation(x, y);
        popupMenu.updateUI();
        popupMenu.setVisible(true);

    }

    private void DividingArmies(final int[][] army) {
        ClearPopupMenu();
        //indexer
        int i = 0;
        //loops for every army in the list
        for (int[] army2 : army) {
            //checks if army on loop index is stationed on selected node
            if (army[i][2] == nodeSelected) {
                //checks to make sure the army is at least an M size
                if (army[i][1] > 5) {
                    //creates the menu item for this army to divide
                    JMenuItem menuItemMove = new JMenuItem(ConvertFullSize(army[i][1], army[i][3]));
                    final int i2 = i;
                    final String listItem = (ConvertFullSize(army[i][1],army[i][3])) +
                            "army at " + (Scenario.listOfNodes[nodeSelected].name) +
                            " has divided";
                    menuItemMove.addActionListener(new ActionListener() {
                        @Override
                        public void actionPerformed(ActionEvent event) {
                            //temporary actions. will change to send to Temp once Temp is done.
                            //labelInfo6.setText(army[0][1] + " is dividing");
                            MapEvent.divideUnit(army[i2][0]);
                            //adds event to list log
                            list1.add(listItem);
                            //try catch for setting default node colours
                            try {
                                SetDefaultColours();
                            } catch (IOException ex) {
                                Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            try {
                                //sets colours of nodes with current player's armies
                                SetEnemyColours();
                            } catch (IOException ex) {
                                Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            SetColours();

                            ClearMenuInfo();
                            ClearPopupMenu();
                        }
                    });
                    //finally, adds this item to the popup menu.
                    popupMenu.add(menuItemMove);
                }

            }
            i++;
        }

        //re-sets the popupmenu as updated and visible
        popupMenu.setLocation(x, y);
        popupMenu.updateUI();
        popupMenu.setVisible(true);

    }

    private void BeginMergingArmies(final int[][] armies) {
        ClearPopupMenu();
        int isFleet = 0;
        //first, it re checks which armies are at this node
        //then it adds a new menu item for each medium or small army so long
        //as there are at least two of that size. x is a secondary indexer.
        if (Global.curPlayer == 0) {
            for (CombatUnit army : Scenario.redPlayer.combatUnits) {
                if (army.location.id == nodeSelected) {
                    for (CombatUnit army2 : Scenario.redPlayer.combatUnits) {
                        if (army2.size < 11 && army2.size == army.size) {
                            if (army2.location.id == nodeSelected && army2.cUnitID != army.cUnitID) {
                                //ensures fleets cannot be merged
                                if (army.isFleet == true) {
                                    isFleet = 1;
                                } else {
                                    isFleet = 0;
                                }
                                if (isFleet == 0) {
                                    //creates the menu item for this army to merge
                                    final int indexer = army.cUnitID;
                                    final int size = army.size;

                                    JMenuItem menuItemMerged = new JMenuItem(ConvertFullSize(army.size, isFleet));
                                    menuItemMerged.addActionListener(new ActionListener() {
                                        @Override
                                        public void actionPerformed(ActionEvent event) {
                                            //sends current array item to MergeArmy method
                                            MergeArmy(indexer, size);
                                        }
                                    });
                                    //finally, adds this item to the popup menu.
                                    popupMenu.add(menuItemMerged);
                                    break;
                                }

                            }
                        }
                    }
                }
            }

        } else if (Global.curPlayer == 1) {
            for (CombatUnit army : Scenario.bluePlayer.combatUnits) {
                //if(army.location.id == nodeSelected) {
                for (CombatUnit army2 : Scenario.bluePlayer.combatUnits) {
                    if (army2.size < 11 && army2.size == army.size) {
                        if (army2.location.id == nodeSelected && army2.cUnitID != army.cUnitID) {
                            //ensures fleets cannot be merged
                            if (army.isFleet == true) {
                                isFleet = 1;
                            } else {
                                isFleet = 0;
                            }
                            if (isFleet == 0) {
                                //creates the menu item for this army to merge
                                final int indexer = army.cUnitID;
                                final int size = army.size;

                                JMenuItem menuItemMerged = new JMenuItem(ConvertFullSize(army.size, isFleet));
                                menuItemMerged.addActionListener(new ActionListener() {
                                    @Override
                                    public void actionPerformed(ActionEvent event) {
                                        //sends current array item to MergeArmy method
                                        MergeArmy(indexer, size);
                                    }
                                });
                                //finally, adds this item to the popup menu.
                                popupMenu.add(menuItemMerged);
                                break;
                            }
                        }
                    }
                }
            }
            //}
        }

        popupMenu.setLocation(x, y);
        popupMenu.updateUI();
        popupMenu.setVisible(true);

    }

    private void MergeArmy(int indexer2, int size) {
        //clears the popup menu
        ClearPopupMenu();

        int isFleet = 0;
        if (Global.curPlayer == 0) {
            for (final CombatUnit army : Scenario.redPlayer.combatUnits) {
                if (army.location.id == nodeSelected) {
                    if (army.cUnitID != indexer2 && army.size == size) {
                        //creates the menu item for this army to merge
                        if (army.isFleet == true) {
                            isFleet = 1;
                        } else {
                            isFleet = 0;
                        }
                        if (isFleet == 0) {
                            //creates the menu item for this army to merge
                            final int indexer = indexer2;
                            final String listItem = (ConvertFullSize(army.size, isFleet)) +
                                "armies at " + (Scenario.listOfNodes[nodeSelected].name) +
                                " have merged";
                            
                            JMenuItem menuItemMerge = new JMenuItem(ConvertFullSize(army.size, isFleet));
                            menuItemMerge.addActionListener(new ActionListener() {
                                @Override
                                public void actionPerformed(ActionEvent event) {
                                    //sends current array item to MergeArmy method
                                    MapEvent.mergeUnits(indexer, army.cUnitID);
                                    
                                    list1.add(listItem);
                                    
                                    try {
                                        SetDefaultColours();
                                    } catch (IOException ex) {
                                        Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                    try {
                                        //sets colours of nodes with current player's armies
                                        SetEnemyColours();
                                    } catch (IOException ex) {
                                        Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                    SetColours();

                                    ClearMenuInfo();
                                    ClearPopupMenu();
                                }
                            });
                            //finally, adds this item to the popup menu.
                            popupMenu.add(menuItemMerge);
                        }
                    }
                }
            }
        } else if (Global.curPlayer == 1) {
            for (final CombatUnit army : Scenario.bluePlayer.combatUnits) {
                if (army.location.id == nodeSelected) {
                    if (army.cUnitID != indexer2 && army.size == size) {
                        //creates the menu item for this army to merge
                        if (army.isFleet == true) {
                            isFleet = 1;
                        } else {
                            isFleet = 0;
                        }
                        if (isFleet == 0) {
                            //creates the menu item for this army to merge
                            final int indexer = indexer2;
                            final String listItem = (ConvertFullSize(army.size, isFleet)) +
                                "armies at " + (Scenario.listOfNodes[nodeSelected].name) +
                                " have merged";

                            JMenuItem menuItemMerge = new JMenuItem(ConvertFullSize(army.size, isFleet));
                            menuItemMerge.addActionListener(new ActionListener() {
                                @Override
                                public void actionPerformed(ActionEvent event) {
                                    //sends current array item to MergeArmy method
                                    MapEvent.mergeUnits(indexer, army.cUnitID);
                                    
                                    list1.add(listItem);
                                    
                                    try {
                                        SetDefaultColours();
                                    } catch (IOException ex) {
                                        Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                    try {
                                        //sets colours of nodes with current player's armies
                                        SetEnemyColours();
                                    } catch (IOException ex) {
                                        Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                    SetColours();

                                    ClearMenuInfo();
                                    ClearPopupMenu();
                                }
                            });
                            //finally, adds this item to the popup menu.
                            popupMenu.add(menuItemMerge);
                        }
                    }
                }
            }
        }

        popupMenu.setLocation(x, y);
        popupMenu.updateUI();
        popupMenu.setVisible(true);
    }


    //converts the army size integer into a single character.
    private String ConvertSize(int armieSize, int isFleet) {
        //creates a string for output
        String size;
        //checks the size for which letter size it is associated with
        if (isFleet == 1) //if it's a fleet, size is always "F" for "Fleet"
        {
            size = "F ";
        } else {
            if (armieSize > 10) //if it's in the "Large" range it gets an "L"
            {
                size = "L ";
            } else if (armieSize > 5) //if in "Medium" size range, it gets an "M"
            {
                size = "M ";
            } else //lastly, for anything under size 6, it gets an "S" for "Small"
            {
                size = "S ";
            }
        }
        return size;
    }

     //converts the army size integer into real words.
    private String ConvertFullSize(int armieSize, int isFleet) {
        //creates a string for output
        String size;
        //checks the size for which letter size it is associated with
        if (isFleet == 1) //if it's a fleet, size is always "F" for "Fleet"
        {
            size = "Fleet ";
        } else {
            if (armieSize > 10) //if it's in the "Large" range it gets an "L"
            {
                size = "Large ";
            } else if (armieSize > 5) //if in "Medium" size range, it gets an "M"
            {
                size = "Medium ";
            } else //lastly, for anything under size 6, it gets an "S" for "Small"
            {
                size = "Small ";
            }
        }
        return size;
    }
    
    private void ClearMenuInfo() {
        /* This method clears all of the visible information presented to
         the player, to end their turn and ensure the next player is
         not given any of their information.                   */

        //empties the text in the info panel
        labelInfo1.setText("");
        labelInfo2.setText("");
        labelInfo3.setText("");
        labelInfo4.setText("");
        labelInfo5.setText("");
        labelInfo6.setText("");
    }

    public void ClearPopupMenu() {
        //empties and hides the popup menu.
        popupMenu.setVisible(false);
        popupMenu.removeAll();
        popupMenu.add(menuItemClose);
    }

    public void SetDefaultColours() throws IOException {
        //this method resets the node colours to default
        Image img;
        //indexer i, which is used as the curent node id in the loop
        int i = 0;
        for (Node nodes : Scenario.listOfNodes) {
            //creates the base image variable

            //checks which player's turn it is
            if (nodes.isPort == true) {
                //sets the image to be a port town node
                img = ImageIO.read(getClass().getResource("Images/map-node-port.png"));
            } else if (nodes.isCity == true) {
                //sets image for cities
                img = ImageIO.read(getClass().getResource("Images/map-node-town.png"));
            } else {
                //else catches the remainder, which are checkpoint locations
                img = ImageIO.read(getClass().getResource("Images/map-node-road.png"));
            }

            //casts the image to an icon
            ImageIcon img2 = new ImageIcon(img);

            //switch case for current indexed button object to change
            switch (i) {
                case 0:
                    nodePlaceholder1.setIcon(img2);
                    break;
                case 1:
                    nodePlaceholder2.setIcon(img2);
                    break;
                case 2:
                    nodePlaceholder3.setIcon(img2);
                    break;
                case 3:
                    nodePlaceholder4.setIcon(img2);
                    break;
                case 4:
                    nodePlaceholder5.setIcon(img2);
                    break;
                case 5:
                    nodePlaceholder6.setIcon(img2);
                    break;
                case 6:
                    nodePlaceholder7.setIcon(img2);
                    break;
                case 7:
                    nodePlaceholder8.setIcon(img2);
                    break;
                case 8:
                    nodePlaceholder9.setIcon(img2);
                    break;
                case 9:
                    nodePlaceholder10.setIcon(img2);
                    break;
                case 10:
                    nodePlaceholder11.setIcon(img2);
                    break;
                case 11:
                    nodePlaceholder12.setIcon(img2);
                    break;
                case 12:
                    nodePlaceholder13.setIcon(img2);
                    break;
                case 13:
                    nodePlaceholder14.setIcon(img2);
                    break;
            }

            //increments i at end of loop
            i++;
        }
    }

    public void SetColours() {
        //this method sets the node colours at the start of each turn.

        //establishes an army array of all player controlled armies
        int[][] armies = null;
        //calls to fill the array
        armies = ObtainArmies(armies);

        //indexer i, which is used as the curent node id in the loop, 
        //followed by a loop for every node (indexer i2) in the list of nodes
        int i = 0;
        for (Node nodes : Scenario.listOfNodes) {

            int i2 = 0;
            //nested loop for going through each army in the army array
            for (int[] armie : armies) {
                //checks if current army in array at index is located at this node
                if (i == armies[i2][2]) {
                    try {
                        SetPlayerNodeColour(i);
                    } catch (IOException ex) {
                        Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
                i2++;
            }

            i++;
        }

    }

    //SetNodeColour houses the switch statement for setting a node colour
    private void SetPlayerNodeColour(int indexer) throws IOException {
        //creates the base image variable
        Image img;
        //checks which player's turn it is
        if (Global.curPlayer == 0) {
            //sets the image to be red or blue, depending on the player
            img = ImageIO.read(getClass().getResource("Images/map-node-red.png"));
            //casts the image to an icon
            ImageIcon img2 = new ImageIcon(img);
            //switch to change the node at index selected
            switch (indexer) {
                case 0:
                    nodePlaceholder1.setIcon(img2);
                    break;
                case 1:
                    nodePlaceholder2.setIcon(img2);
                    break;
                case 2:
                    nodePlaceholder3.setIcon(img2);
                    break;
                case 3:
                    nodePlaceholder4.setIcon(img2);
                    break;
                case 4:
                    nodePlaceholder5.setIcon(img2);
                    break;
                case 5:
                    nodePlaceholder6.setIcon(img2);
                    break;
                case 6:
                    nodePlaceholder7.setIcon(img2);
                    break;
                case 7:
                    nodePlaceholder8.setIcon(img2);
                    break;
                case 8:
                    nodePlaceholder9.setIcon(img2);
                    break;
                case 9:
                    nodePlaceholder10.setIcon(img2);
                    break;
                case 10:
                    nodePlaceholder11.setIcon(img2);
                    break;
                case 11:
                    nodePlaceholder12.setIcon(img2);
                    break;
                case 12:
                    nodePlaceholder13.setIcon(img2);
                    break;
                case 13:
                    nodePlaceholder14.setIcon(img2);
                    break;
            }
        } else if (Global.curPlayer == 1) {
            //exact same as above but with blue team png called to
            img = ImageIO.read(getClass().getResource("Images/map-node-blue.png"));
            ImageIcon img2 = new ImageIcon(img);
            switch (indexer) {
                case 0:
                    nodePlaceholder1.setIcon(img2);
                    break;
                case 1:
                    nodePlaceholder2.setIcon(img2);
                    break;
                case 2:
                    nodePlaceholder3.setIcon(img2);
                    break;
                case 3:
                    nodePlaceholder4.setIcon(img2);
                    break;
                case 4:
                    nodePlaceholder5.setIcon(img2);
                    break;
                case 5:
                    nodePlaceholder6.setIcon(img2);
                    break;
                case 6:
                    nodePlaceholder7.setIcon(img2);
                    break;
                case 7:
                    nodePlaceholder8.setIcon(img2);
                    break;
                case 8:
                    nodePlaceholder9.setIcon(img2);
                    break;
                case 9:
                    nodePlaceholder10.setIcon(img2);
                    break;
                case 10:
                    nodePlaceholder11.setIcon(img2);
                    break;
                case 11:
                    nodePlaceholder12.setIcon(img2);
                    break;
                case 12:
                    nodePlaceholder13.setIcon(img2);
                    break;
                case 13:
                    nodePlaceholder14.setIcon(img2);
                    break;
            }
        }
    }
    
    private void SetEnemyColours() throws IOException {
        int i = 0; 
        ArrayList<ArrayList<Integer>> intelList;
        if(Global.curPlayer == 0)
            intelList = Scenario.redPlayer.enemyIntelligence;
        else
            intelList = Scenario.bluePlayer.enemyIntelligence;

        //first it checks if there is any intel
        if(intelList.isEmpty() != true)
        {
            for(ArrayList<Integer> intel : intelList) {
                if(intel.isEmpty() == false)
                {
                    //sets the node of index to opposing team colour
                    Image img;
                    if(Global.curPlayer == 0)
                        img = ImageIO.read(getClass().getResource("Images/map-node-blue.png"));
                    else
                        img = ImageIO.read(getClass().getResource("Images/map-node-red.png"));

                    ImageIcon img2 = new ImageIcon(img);
                
                        switch (i) {
                        case 0:
                            nodePlaceholder1.setIcon(img2);
                            break;
                        case 1:
                            nodePlaceholder2.setIcon(img2);
                            break;
                        case 2:
                            nodePlaceholder3.setIcon(img2);
                            break;
                        case 3:
                            nodePlaceholder4.setIcon(img2);
                            break;
                        case 4:
                            nodePlaceholder5.setIcon(img2);
                            break;
                        case 5:
                            nodePlaceholder6.setIcon(img2);
                            break;
                        case 6:
                            nodePlaceholder7.setIcon(img2);
                            break;
                        case 7:
                            nodePlaceholder8.setIcon(img2);
                            break;
                        case 8:
                            nodePlaceholder9.setIcon(img2);
                            break;
                        case 9:
                            nodePlaceholder10.setIcon(img2);
                            break;
                        case 10:
                            nodePlaceholder11.setIcon(img2);
                            break;
                        case 11:
                            nodePlaceholder12.setIcon(img2);
                            break;
                        case 12:
                            nodePlaceholder13.setIcon(img2);
                            break;
                        case 13:
                            nodePlaceholder14.setIcon(img2);
                            break;
                    }
                }

                //increments i, which keeps track of indexing
                i++;
            }
        }
    }

    private void SetCurrentColour() throws IOException {
        //sets the node selected to a white background
        Image img;
        img = ImageIO.read(getClass().getResource("Images/map-node-selected.png"));
        ImageIcon img2 = new ImageIcon(img);
        switch (nodeSelected) {
            case 0:
                nodePlaceholder1.setIcon(img2);
                break;
            case 1:
                nodePlaceholder2.setIcon(img2);
                break;
            case 2:
                nodePlaceholder3.setIcon(img2);
                break;
            case 3:
                nodePlaceholder4.setIcon(img2);
                break;
            case 4:
                nodePlaceholder5.setIcon(img2);
                break;
            case 5:
                nodePlaceholder6.setIcon(img2);
                break;
            case 6:
                nodePlaceholder7.setIcon(img2);
                break;
            case 7:
                nodePlaceholder8.setIcon(img2);
                break;
            case 8:
                nodePlaceholder9.setIcon(img2);
                break;
            case 9:
                nodePlaceholder10.setIcon(img2);
                break;
            case 10:
                nodePlaceholder11.setIcon(img2);
                break;
            case 11:
                nodePlaceholder12.setIcon(img2);
                break;
            case 12:
                nodePlaceholder13.setIcon(img2);
                break;
            case 13:
                nodePlaceholder14.setIcon(img2);
                break;
        }
    }
    
    private void EnemiesHere() {
        String enemies = "";
        ArrayList<Integer> intel;
        if(Global.curPlayer == 0)
            intel = Scenario.redPlayer.enemyIntelligence.get(nodeSelected);
        else
            intel = Scenario.bluePlayer.enemyIntelligence.get(nodeSelected);

        if(intel.isEmpty() == true)
            enemies = "none known to be here";
        else
            for(int fog : intel) {
                if(fog == 3)
                    enemies += (" " + ConvertSize(5, 1));
                else if(fog == 2)
                    enemies += (" " + ConvertSize(15, 0));
                else if(fog == 1)
                    enemies += (" " + ConvertSize(10, 0));
                else if(fog == 0)
                    enemies += (" " + ConvertSize (5, 0));
            }
        
        labelInfo6.setText("Enemies here: " + enemies);
    }
    
    
    
    
    /*Placeholder nodes set the nodeSelected value, then call action.
     all of the nodes do the same actions: set the global value for
     the selected node's index value, sets the globals for the selected
     node's x and y values on the gui, then calls to the Action method */

    private void nodePlaceholder1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder1ActionPerformed
        nodeSelected = 0;
        x = nodePlaceholder1.getX();
        y = nodePlaceholder1.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder1ActionPerformed

    private void nodePlaceholder2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder2ActionPerformed
        nodeSelected = 1;
        x = nodePlaceholder2.getX();
        y = nodePlaceholder2.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder2ActionPerformed

    private void nodePlaceholder3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder3ActionPerformed
        nodeSelected = 2;
        x = nodePlaceholder3.getX();
        y = nodePlaceholder3.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder3ActionPerformed

    private void nodePlaceholder4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder4ActionPerformed
        nodeSelected = 3;
        x = nodePlaceholder4.getX();
        y = nodePlaceholder4.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder4ActionPerformed

    private void nodePlaceholder5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder5ActionPerformed
        nodeSelected = 4;
        x = nodePlaceholder5.getX();
        y = nodePlaceholder5.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder5ActionPerformed

    private void nodePlaceholder6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder6ActionPerformed
        nodeSelected = 5;
        x = nodePlaceholder6.getX();
        y = nodePlaceholder6.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder6ActionPerformed

    private void nodePlaceholder7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder7ActionPerformed
        nodeSelected = 6;
        x = nodePlaceholder7.getX();
        y = nodePlaceholder7.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder7ActionPerformed

    private void nodePlaceholder8ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder8ActionPerformed
        nodeSelected = 7;
        x = nodePlaceholder8.getX();
        y = nodePlaceholder8.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder8ActionPerformed

    private void nodePlaceholder9ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder9ActionPerformed
        nodeSelected = 8;
        x = nodePlaceholder9.getX();
        y = nodePlaceholder9.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder9ActionPerformed

    private void nodePlaceholder10ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder10ActionPerformed
        nodeSelected = 9;
        x = nodePlaceholder10.getX();
        y = nodePlaceholder10.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder10ActionPerformed

    private void nodePlaceholder11ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder11ActionPerformed
        nodeSelected = 10;
        x = nodePlaceholder11.getX();
        y = nodePlaceholder11.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder11ActionPerformed

    private void nodePlaceholder12ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder12ActionPerformed
        nodeSelected = 11;
        x = nodePlaceholder12.getX();
        y = nodePlaceholder12.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder12ActionPerformed

    private void nodePlaceholder13ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder13ActionPerformed
        nodeSelected = 12;
        x = nodePlaceholder13.getX();
        y = nodePlaceholder13.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder13ActionPerformed

    private void nodePlaceholder14ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodePlaceholder14ActionPerformed
        nodeSelected = 13;
        x = nodePlaceholder14.getX();
        y = nodePlaceholder14.getY();
        Action();
    }//GEN-LAST:event_nodePlaceholder14ActionPerformed

    private void menuItemCloseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuItemCloseActionPerformed
        //a base menu item always added to the popup menu that, when clicked,
        //clears and closes the popup menu.
        ClearPopupMenu();

        try {
            SetDefaultColours();
        } catch (IOException ex) {
            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
        }
        SetColours();
    }//GEN-LAST:event_menuItemCloseActionPerformed

    private void popupMenuFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_popupMenuFocusLost
        // TODO add your handling code here:
    }//GEN-LAST:event_popupMenuFocusLost

    private void buttonMapImageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonMapImageActionPerformed
        ClearPopupMenu();
        try {
            SetDefaultColours();
        } catch (IOException ex) {
            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
        }
        SetColours();
    }//GEN-LAST:event_buttonMapImageActionPerformed

    private void buttonMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonMenuActionPerformed
        //button for quitting current scenario and returning to main menu
        Scenario.killSwitch();

        ClearPopupMenu();
        ClearMenuInfo();

        new MainMenu().setVisible(true);
        Map.this.dispose();
        Map.this.frameFloatingInfo.dispose();
    }//GEN-LAST:event_buttonMenuActionPerformed

    private void buttonExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonExitActionPerformed
        System.exit(0);
    }//GEN-LAST:event_buttonExitActionPerformed

    private void buttonNextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonNextActionPerformed
        buttonNext.setVisible(false);
        buttonFinishTurn.setEnabled(true);
        panelMap.setVisible(true);
    }//GEN-LAST:event_buttonNextActionPerformed

    private void buttonFinishTurnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonFinishTurnActionPerformed
        //removes all text
        buttonFinishTurn.setEnabled(false);
        list1.removeAll();
        ClearMenuInfo();
        ClearPopupMenu();
        
        //for the next player
        if (Global.curPlayer == 0) {
            Global.curPlayer = 1;
            labelCurPlayer.setText("Blue team's turn");
            buttonNext.setText("Blue team, click here to proceed.");            
        } else {
            Global.curPlayer = 0;
            labelCurPlayer.setText("Red team's turn");
            buttonNext.setText("Red team, click here to proceed.");
        }
        
        panelMap.setVisible(false);
        //actions to finish the turn on th ebackend

        Scenario.game.endTurn();
        
        buttonNext.setVisible(true);

        labelTurnCount.setText("Turn: " + ((int) Game.turnCount + 1));
        
        //sets label that displays season
        if(Global.season == 0)
            labelSeason.setText("Season: Winter");
        else if(Global.season == 1)
            labelSeason.setText("Season: Spring");
        else if(Global.season == 2)
            labelSeason.setText("Season: Summer");
        else if(Global.season == 3)
            labelSeason.setText("Season: Autumn");
        
        //sets label that displays current political power level
        if(Global.curPlayer == 0)
            labelPoliticalPower.setText("Political power: " + Scenario.redPlayer.politicalPower);
        else
            labelPoliticalPower.setText("Political power: " + Scenario.bluePlayer.politicalPower);

        //try catch for setting default node colours
        try {
            SetDefaultColours();
        } catch (IOException ex) {
            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
        }
        //sets colours of nodes with current player's armies
        SetColours();
    }//GEN-LAST:event_buttonFinishTurnActionPerformed

    private void buttonBackdropActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonBackdropActionPerformed
        ClearPopupMenu();
        try {
            SetDefaultColours();
        } catch (IOException ex) {
            Logger.getLogger(Map.class.getName()).log(Level.SEVERE, null, ex);
        }
        SetColours();
    }//GEN-LAST:event_buttonBackdropActionPerformed

    private void butonXActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_butonXActionPerformed
        System.exit(0);
    }//GEN-LAST:event_butonXActionPerformed

    /**
     * @param args the command line arguments
     */
    public void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Map.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Map.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Map.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Map.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new Map().setVisible(true);
            }

        });

    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton butonX;
    private javax.swing.JButton buttonBackdrop;
    private javax.swing.JButton buttonExit;
    private javax.swing.JButton buttonFinishTurn;
    private javax.swing.JButton buttonMapImage;
    private javax.swing.JToggleButton buttonMenu;
    private javax.swing.JButton buttonNext;
    private javax.swing.JFrame frameFloatingInfo;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JLabel labelBackdrop;
    private javax.swing.JLabel labelCurPlayer;
    private javax.swing.JLabel labelInfo1;
    private javax.swing.JLabel labelInfo2;
    private javax.swing.JLabel labelInfo3;
    private javax.swing.JLabel labelInfo4;
    private javax.swing.JLabel labelInfo5;
    private javax.swing.JLabel labelInfo6;
    private javax.swing.JLabel labelOpponent;
    private javax.swing.JLabel labelPoliticalPower;
    private javax.swing.JLabel labelScenario;
    private javax.swing.JLabel labelSeason;
    private javax.swing.JLabel labelTurnCount;
    private java.awt.List list1;
    private javax.swing.JPanel menuInfo;
    private javax.swing.JMenuItem menuItemClose;
    private javax.swing.JButton nodePlaceholder1;
    private javax.swing.JButton nodePlaceholder10;
    private javax.swing.JButton nodePlaceholder11;
    private javax.swing.JButton nodePlaceholder12;
    private javax.swing.JButton nodePlaceholder13;
    private javax.swing.JButton nodePlaceholder14;
    private javax.swing.JButton nodePlaceholder2;
    private javax.swing.JButton nodePlaceholder3;
    private javax.swing.JButton nodePlaceholder4;
    private javax.swing.JButton nodePlaceholder5;
    private javax.swing.JButton nodePlaceholder6;
    private javax.swing.JButton nodePlaceholder7;
    private javax.swing.JButton nodePlaceholder8;
    private javax.swing.JButton nodePlaceholder9;
    private javax.swing.JPanel panelMap;
    private javax.swing.JPopupMenu popupMenu;
    // End of variables declaration//GEN-END:variables
}
